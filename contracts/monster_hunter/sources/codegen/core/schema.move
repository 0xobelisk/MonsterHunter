  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module monster_hunter::monster_hunter_schema {

  use std::ascii::String;

  use std::ascii::string;

  use sui::package::UpgradeCap;

  use std::type_name;

  use dubhe::storage;

  use dubhe::storage_value::{Self, StorageValue};

  use dubhe::storage_map::{Self, StorageMap};

  use dubhe::storage_double_map::{Self, StorageDoubleMap};

  use sui::dynamic_field as df;

  use monster_hunter::monster_hunter_dapp_metadata::DappMetadata;

  use monster_hunter::monster_hunter_monster_type::MonsterType;

  use monster_hunter::monster_hunter_direction::Direction;

  use monster_hunter::monster_hunter_terrain_type::TerrainType;

  use monster_hunter::monster_hunter_monster_catch_result::MonsterCatchResult;

  use monster_hunter::monster_hunter_map_config::MapConfig;

  use monster_hunter::monster_hunter_position::Position;

  use monster_hunter::monster_hunter_encounter_info::EncounterInfo;

  public struct Schema has key, store {
    id: UID,
  }

  // Default storage

  public fun borrow_dapp__admin(self: &Schema): &StorageValue<address> {
    storage::borrow_field(&self.id, b"dapp__admin")
  }

  public fun borrow_dapp__package_id(self: &Schema): &StorageValue<address> {
    storage::borrow_field(&self.id, b"dapp__package_id")
  }

  public fun borrow_dapp__version(self: &Schema): &StorageValue<u32> {
    storage::borrow_field(&self.id, b"dapp__version")
  }

  public fun borrow_dapp__metadata(self: &Schema): &StorageValue<DappMetadata> {
    storage::borrow_field(&self.id, b"dapp__metadata")
  }

  public fun borrow_dapp__safe_mode(self: &Schema): &StorageValue<bool> {
    storage::borrow_field(&self.id, b"dapp__safe_mode")
  }

  public fun borrow_dapp__authorised_schemas(self: &Schema): &StorageValue<vector<address>> {
    storage::borrow_field(&self.id, b"dapp__authorised_schemas")
  }

  public fun borrow_dapp__schemas(self: &Schema): &StorageValue<vector<address>> {
    storage::borrow_field(&self.id, b"dapp__schemas")
  }

  public(package) fun dapp__admin(self: &mut Schema): &mut StorageValue<address> {
    storage::borrow_mut_field(&mut self.id, b"dapp__admin")
  }

  public(package) fun dapp__package_id(self: &mut Schema): &mut StorageValue<address> {
    storage::borrow_mut_field(&mut self.id, b"dapp__package_id")
  }

  public(package) fun dapp__version(self: &mut Schema): &mut StorageValue<u32> {
    storage::borrow_mut_field(&mut self.id, b"dapp__version")
  }

  public(package) fun dapp__metadata(self: &mut Schema): &mut StorageValue<DappMetadata> {
    storage::borrow_mut_field(&mut self.id, b"dapp__metadata")
  }

  public(package) fun dapp__safe_mode(self: &mut Schema): &mut StorageValue<bool> {
    storage::borrow_mut_field(&mut self.id, b"dapp__safe_mode")
  }

  public(package) fun dapp__authorised_schemas(self: &mut Schema): &mut StorageValue<vector<address>> {
    storage::borrow_mut_field(&mut self.id, b"dapp__authorised_schemas")
  }

  public fun borrow_player(self: &Schema): &StorageMap<address, bool> {
    storage::borrow_field(&self.id, b"player")
  }

  public(package) fun player(self: &mut Schema): &mut StorageMap<address, bool> {
    storage::borrow_mut_field(&mut self.id, b"player")
  }

  public fun borrow_moveable(self: &Schema): &StorageMap<address, bool> {
    storage::borrow_field(&self.id, b"moveable")
  }

  public(package) fun moveable(self: &mut Schema): &mut StorageMap<address, bool> {
    storage::borrow_mut_field(&mut self.id, b"moveable")
  }

  public fun borrow_position(self: &Schema): &StorageMap<address, Position> {
    storage::borrow_field(&self.id, b"position")
  }

  public(package) fun position(self: &mut Schema): &mut StorageMap<address, Position> {
    storage::borrow_mut_field(&mut self.id, b"position")
  }

  public fun borrow_obstruction(self: &Schema): &StorageMap<Position, bool> {
    storage::borrow_field(&self.id, b"obstruction")
  }

  public(package) fun obstruction(self: &mut Schema): &mut StorageMap<Position, bool> {
    storage::borrow_mut_field(&mut self.id, b"obstruction")
  }

  public fun borrow_map_config(self: &Schema): &StorageValue<MapConfig> {
    storage::borrow_field(&self.id, b"map_config")
  }

  public(package) fun map_config(self: &mut Schema): &mut StorageValue<MapConfig> {
    storage::borrow_mut_field(&mut self.id, b"map_config")
  }

  public fun borrow_encounterable(self: &Schema): &StorageMap<address, bool> {
    storage::borrow_field(&self.id, b"encounterable")
  }

  public(package) fun encounterable(self: &mut Schema): &mut StorageMap<address, bool> {
    storage::borrow_mut_field(&mut self.id, b"encounterable")
  }

  public fun borrow_encounter_trigger(self: &Schema): &StorageMap<Position, bool> {
    storage::borrow_field(&self.id, b"encounter_trigger")
  }

  public(package) fun encounter_trigger(self: &mut Schema): &mut StorageMap<Position, bool> {
    storage::borrow_mut_field(&mut self.id, b"encounter_trigger")
  }

  public fun borrow_encounter(self: &Schema): &StorageMap<address, EncounterInfo> {
    storage::borrow_field(&self.id, b"encounter")
  }

  public(package) fun encounter(self: &mut Schema): &mut StorageMap<address, EncounterInfo> {
    storage::borrow_mut_field(&mut self.id, b"encounter")
  }

  public fun borrow_monster(self: &Schema): &StorageMap<address, MonsterType> {
    storage::borrow_field(&self.id, b"monster")
  }

  public(package) fun monster(self: &mut Schema): &mut StorageMap<address, MonsterType> {
    storage::borrow_mut_field(&mut self.id, b"monster")
  }

  public fun borrow_owned_by(self: &Schema): &StorageMap<address, address> {
    storage::borrow_field(&self.id, b"owned_by")
  }

  public(package) fun owned_by(self: &mut Schema): &mut StorageMap<address, address> {
    storage::borrow_mut_field(&mut self.id, b"owned_by")
  }

  public(package) fun create(ctx: &mut TxContext): Schema {
    let mut id = object::new(ctx);
    storage::add_field<StorageMap<address, bool>>(&mut id, b"player", storage_map::new(b"player", ctx));
    storage::add_field<StorageMap<address, bool>>(&mut id, b"moveable", storage_map::new(b"moveable", ctx));
    storage::add_field<StorageMap<address, Position>>(&mut id, b"position", storage_map::new(b"position", ctx));
    storage::add_field<StorageMap<Position, bool>>(&mut id, b"obstruction", storage_map::new(b"obstruction", ctx));
    storage::add_field<StorageValue<MapConfig>>(&mut id, b"map_config", storage_value::new(b"map_config", ctx));
    storage::add_field<StorageMap<address, bool>>(&mut id, b"encounterable", storage_map::new(b"encounterable", ctx));
    storage::add_field<StorageMap<Position, bool>>(&mut id, b"encounter_trigger", storage_map::new(b"encounter_trigger", ctx));
    storage::add_field<StorageMap<address, EncounterInfo>>(&mut id, b"encounter", storage_map::new(b"encounter", ctx));
    storage::add_field<StorageMap<address, MonsterType>>(&mut id, b"monster", storage_map::new(b"monster", ctx));
    storage::add_field<StorageMap<address, address>>(&mut id, b"owned_by", storage_map::new(b"owned_by", ctx));
    Schema { id }
  }

  public(package) fun id(self: &mut Schema): &mut UID {
    &mut self.id
  }

  public(package) fun borrow_id(self: &Schema): &UID {
    &self.id
  }

  public fun migrate(_schema: &mut Schema, _cap: &UpgradeCap, _ctx: &mut TxContext) {}

  // ======================================== View Functions ========================================

  public fun get_player(self: &Schema, key: address): &bool {
    self.borrow_player().get(key)
  }

  public fun get_moveable(self: &Schema, key: address): &bool {
    self.borrow_moveable().get(key)
  }

  public fun get_position(self: &Schema, key: address): &Position {
    self.borrow_position().get(key)
  }

  public fun get_obstruction(self: &Schema, key: Position): &bool {
    self.borrow_obstruction().get(key)
  }

  public fun get_map_config(self: &Schema): &MapConfig {
    self.borrow_map_config().get()
  }

  public fun get_encounterable(self: &Schema, key: address): &bool {
    self.borrow_encounterable().get(key)
  }

  public fun get_encounter_trigger(self: &Schema, key: Position): &bool {
    self.borrow_encounter_trigger().get(key)
  }

  public fun get_encounter(self: &Schema, key: address): &EncounterInfo {
    self.borrow_encounter().get(key)
  }

  public fun get_monster(self: &Schema, key: address): &MonsterType {
    self.borrow_monster().get(key)
  }

  public fun get_owned_by(self: &Schema, key: address): &address {
    self.borrow_owned_by().get(key)
  }

  // =========================================================================================================
}
