  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module monster_hunter::monster_hunter_deploy_hook {

  use dubhe::dapp_hub::DappHub;
  use monster_hunter::monster_hunter_dapp_key;
  use monster_hunter::monster_hunter_terrain_type;
  use monster_hunter::entity_id::position_to_entity_id;
  use monster_hunter::monster_hunter_position;
  use monster_hunter::monster_hunter_obstruction;
  use monster_hunter::monster_hunter_encounter_trigger;
  use monster_hunter::monster_hunter_map_config;
  use sui::bcs::{Self, to_bytes, peel_enum_tag};

  public(package) fun run(dapp_hub: &mut DappHub, _ctx: &mut TxContext) {
			let  o = monster_hunter_terrain_type::new_none();
      let  t = monster_hunter_terrain_type::new_tallgrass();
      let  b = monster_hunter_terrain_type::new_boulder();
			let map = vector[
      vector[o, o, o, o, o, o, t, o, o, o, o, o, o, o, o, o, o, o, o, o],
      vector[o, o, t, o, o, o, o, o, t, o, o, o, o, b, o, o, o, o, o, o],
      vector[t, t, t, t, t, o, o, o, o, o, o, o, o, o, o, t, t, o, o, o],
      vector[o, o, t, t, t, t, o, o, o, o, b, o, o, o, o, o, t, o, o, o],
      vector[o, o, o, o, t, t, o, o, o, o, o, o, o, o, o, o, o, t, o, o],
      vector[o, o, o, b, b, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o],
      vector[t, o, o, o, o, b, b, o, o, o, o, t, o, o, o, o, o, b, o, o],
      vector[o, o, t, t, o, o, o, o, o, t, o, b, o, o, t, o, b, o, o, o],
      vector[o, o, t, o, o, o, o, t, t, t, o, b, b, o, o, o, o, o, o, o],
      vector[o, o, o, o, o, o, o, t, t, t, o, b, t, o, t, t, o, o, o, o],
      vector[o, b, o, o, o, b, o, o, t, t, o, b, o, o, t, t, o, o, o, o],
      vector[o, o, b, o, o, o, t, o, t, t, o, o, b, t, t, t, o, o, o, o],
      vector[o, o, b, b, o, o, o, o, t, o, o, o, b, o, t, o, o, o, o, o],
      vector[o, o, o, b, b, o, o, o, o, o, o, o, o, b, o, t, o, o, o, o],
      vector[o, o, o, o, b, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o],
      vector[o, o, o, o, o, o, o, o, o, o, b, b, o, o, t, o, o, o, o, o],
      vector[o, o, o, o, t, o, o, o, t, b, o, o, o, t, t, o, b, o, o, o],
      vector[o, o, o, t, o, t, t, t, o, o, o, o, o, t, o, o, o, o, o, o],
      vector[o, o, o, t, t, t, t, o, o, o, o, t, o, o, o, t, o, o, o, o],
      vector[o, o, o, o, o, t, o, o, o, o, o, o, o, o, o, o, o, o, o, o],
    ];

        let height = map.length();
        let width = map[0].length();
        let mut terrain = vector::empty();
       
        let mut y: u64 = 0;
        while (y < height) {
           let mut x: u64 = 0;
            while (x < width) {
                let terrain_type = map[y][x];
                let entity = position_to_entity_id(x, y);
                match (terrain_type) {
                    o => {},
                    b => {
                     monster_hunter_position::set(dapp_hub, entity, x, y);
                     monster_hunter_obstruction::set(dapp_hub, entity);
                    },
                    t => {
                      monster_hunter_position::set(dapp_hub, entity, x, y);
                      monster_hunter_encounter_trigger::set(dapp_hub, entity);
                    },
                };
                // y * width + x
                let raw_enum_index = to_bytes(&terrain_type);
                let index = peel_enum_tag(&mut bcs::new(raw_enum_index));
                terrain.push_back(index);
                x = x + 1;
            };
            y = y + 1;
        };

        monster_hunter_map_config::set(
          dapp_hub, 
          width, 
          height, 
          terrain
        );
  }
}
